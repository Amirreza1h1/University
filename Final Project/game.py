import random
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import mm as main

class Game():
    def __init__(self):
        pass

    def get_bot_numbers(self):
        bot_numbers = {}

        print("\nEnter the number of bots for each category:")
        always_betray = int(input("AlwaysBetray: "))
        always_cooperate = int(input("AlwaysCooperate: "))
        random_80_player = int(input("Random-80 percent defiant: "))
        random_50_player = int(input("Random-50 percent defiant: "))
        random_20_player = int(input("Random-20 percent defiant: "))
        adaptive_bot = int(input("AdaptiveBot: "))
        # fuzzy_bot = int(input("FuzzyBot: "))

        bot_numbers['AlwaysBetray'] = always_betray
        bot_numbers['AlwaysCooperate'] = always_cooperate
        bot_numbers['Random_80'] = random_80_player
        bot_numbers['Random_50'] = random_50_player
        bot_numbers['Random_20'] = random_20_player
        bot_numbers['AdaptiveBot'] = adaptive_bot
        # bot_numbers['FuzzyBot'] = fuzzy_bot

        return bot_numbers

    def play_round(self, player1, player2, history):
        if not player1.alive or not player2.alive:
            return history, 0

        move1 = player1.play(history)
        move2 = player2.play(history)
        history.append((move1, move2))
        outcome1, outcome2 = main.rule[(move1, move2)]

        player1.update_score(outcome1)
        player2.update_score(outcome2)

        # Count a crash if both players chose 'Defiant'
        crash = 1 if (move1 == 'Defiant' and move2 == 'Defiant') else 0
        return history, crash

    def reproduce_population(self, population):
        population.sort(key=lambda player: player.score, reverse=True)

        percentage_count = len(population) // 10
        number_of_dead = sum(1 for player in population if not player.alive)

        if number_of_dead < percentage_count:
            population = [player for player in population if player.alive][:-percentage_count]

        top_players = population[:percentage_count]
        offspring_pop = []
        for player in top_players:
            child = player.reproduce()
            offspring_pop.append(child)
            population.append(child)

        return population, offspring_pop

    def simulate_game_population(self, population, rounds=100):
        history = []

        type_counts = {player.type: [] for player in population}
        crash_count = []
        offspring_counts = {ptype: 0 for ptype in type_counts}

        fig, axes = plt.subplots(3, 1, figsize=(10, 18))

        def update(frame):
            nonlocal population, history

            # Play rounds
            random.shuffle(population)
            round_crashes = 0  # Count crashes for the current round
            i = 0
            while i < len(population) - 1:
                player1 = population[i]
                player2 = population[i + 1]

                # Play a round, update history, and count crashes
                history, crash = self.play_round(player1, player2, history)
                round_crashes += crash

                i += 2
            
            crash_count.append(round_crashes)


            # Reproduce population
            population, offspring_pop = self.reproduce_population(population)

            # Update type counts
            current_counts = {ptype: 0 for ptype in type_counts}
            for player in population:
                current_counts[player.type] += 1
            for ptype in type_counts:
                type_counts[ptype].append(current_counts[ptype])

            # Update offspring counts
            for player in offspring_pop:
                offspring_counts[player.type] += 1

            # Clear and redraw plots
            for ax in axes:
                ax.clear()

            # Plot type counts
            for ptype, counts in type_counts.items():
                axes[0].plot(counts, label=ptype)
            axes[0].set_title("Player Counts by Type")
            axes[0].set_xlabel("Round")
            axes[0].set_ylabel("Count")
            axes[0].legend()

            # Update the second subplot with crashes
            axes[1].plot(crash_count, label="Crashes per Round", color='orange')
            axes[1].set_title("Crashes per Round")
            axes[1].set_xlabel("Round")
            axes[1].set_ylabel("Count")
            axes[1].legend()

            # Plot offspring counts
            axes[2].bar(offspring_counts.keys(), offspring_counts.values())
            axes[2].set_title("Offspring Generated by Type")
            axes[2].set_xlabel("Player Type")
            axes[2].set_ylabel("Offspring Count")

            plt.tight_layout()

        ani = animation.FuncAnimation(fig, update, frames=rounds, repeat=False)
        plt.show()
